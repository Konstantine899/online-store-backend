# –°–∏—Å—Ç–µ–º–∞ –ø–ª–∞—Ç–µ–∂–µ–π (Payment System) - Ecommerce Edition

## –ö–æ–Ω—Ç–µ–∫—Å—Ç –∏ —Ü–µ–ª—å
–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∞–∫—Ç–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã –ø–ª–∞—Ç–µ–∂–µ–π –¥–ª—è ecommerce –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å –±–∞–∑–æ–≤—ã–º–∏ —Å—Ç–∞—Ç—É—Å–∞–º–∏, –ø—Ä–æ—Å—Ç—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏ –æ–ø–ª–∞—Ç—ã –∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π —Å –≤–Ω–µ—à–Ω–∏–º–∏ —à–ª—é–∑–∞–º–∏, —Ñ–æ–∫—É—Å–æ–º –Ω–∞ –±—ã—Å—Ç—Ä—É—é —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É –∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—é.

## –û—Å–Ω–æ–≤–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
- **–ë–∞–∑–æ–≤—ã–µ —Å—Ç–∞—Ç—É—Å—ã** - pending, completed, failed, refunded
- **–ü—Ä–æ—Å—Ç—ã–µ –º–µ—Ç–æ–¥—ã –æ–ø–ª–∞—Ç—ã** - card, cash, bank_transfer
- **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —à–ª—é–∑–∞–º–∏** - –±–µ–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º–µ—Ç–æ–¥–æ–≤ –ø–ª–∞—Ç–µ–∂–µ–π
- **–í–æ–∑–≤—Ä–∞—Ç—ã** - –ø—Ä–æ—Å—Ç–æ–π —Å—Ç–∞—Ç—É—Å refunded
- **–ò—Å—Ç–æ—Ä–∏—è –ø–ª–∞—Ç–µ–∂–µ–π** - –¥–ª—è –∑–∞–∫–∞–∑–æ–≤
- **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –±–µ–∑ —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö

### –¢–∞–±–ª–∏—Ü–∞ `payments`
```sql
CREATE TABLE payments (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id) ON DELETE CASCADE,
    amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'RUB',
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'failed', 'refunded')),
    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('card', 'cash', 'bank_transfer')),
    gateway_name VARCHAR(50),
    gateway_transaction_id VARCHAR(255),
    gateway_response JSONB,
    description TEXT,
    refund_amount DECIMAL(10,2) DEFAULT 0,
    refund_reason TEXT,
    is_recurring BOOLEAN DEFAULT false,
    is_partial BOOLEAN DEFAULT false,
    is_prepaid BOOLEAN DEFAULT false,
    is_refundable BOOLEAN DEFAULT true,
    is_processed BOOLEAN DEFAULT false,
    is_settled BOOLEAN DEFAULT false,
    is_archived BOOLEAN DEFAULT false,
    is_auto_renewal BOOLEAN DEFAULT false,
    is_installment BOOLEAN DEFAULT false,
    processed_at TIMESTAMP,
    failed_at TIMESTAMP,
    refunded_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## –ú–æ–¥–µ–ª–∏ Sequelize

### Payment Model
```typescript
// src/domain/models/payment.model.ts
import { Model, DataType, Column, Table, BelongsTo, ForeignKey } from 'sequelize-typescript';
import { OrderModel } from './order.model';

export enum PaymentStatus {
    PENDING = 'pending',
    COMPLETED = 'completed',
    FAILED = 'failed',
    REFUNDED = 'refunded'
}

export enum PaymentMethod {
    CARD = 'card',
    CASH = 'cash',
    BANK_TRANSFER = 'bank_transfer'
}

interface IPaymentModel {
    id: number;
    orderId: number;
    amount: number;
    currency: string;
    status: PaymentStatus;
    paymentMethod: PaymentMethod;
    gatewayName?: string;
    gatewayTransactionId?: string;
    gatewayResponse?: any;
    description?: string;
    refundAmount: number;
    refundReason?: string;
    processedAt?: Date;
    failedAt?: Date;
    refundedAt?: Date;
    isRecurring: boolean;
    isPartial: boolean;
    isPrepaid: boolean;
    isRefundable: boolean;
    isProcessed: boolean;
    isSettled: boolean;
    isArchived: boolean;
    isAutoRenewal: boolean;
    isInstallment: boolean;
    order: OrderModel;
    createdAt: Date;
    updatedAt: Date;
}

interface IPaymentCreationAttributes {
    orderId: number;
    amount: number;
    currency?: string;
    status?: PaymentStatus;
    paymentMethod: PaymentMethod;
    gatewayName?: string;
    gatewayTransactionId?: string;
    gatewayResponse?: any;
    description?: string;
    isRecurring?: boolean;
    isPartial?: boolean;
    isPrepaid?: boolean;
    isRefundable?: boolean;
    isProcessed?: boolean;
    isSettled?: boolean;
    isArchived?: boolean;
    isAutoRenewal?: boolean;
    isInstallment?: boolean;
}

@Table({
    tableName: 'payments',
    underscored: true,
    timestamps: true,
    indexes: [
        { fields: ['order_id'], name: 'idx_payments_order_id' },
        { fields: ['status'], name: 'idx_payments_status' },
        { fields: ['payment_method'], name: 'idx_payments_payment_method' },
        { fields: ['gateway_name'], name: 'idx_payments_gateway_name' },
        { fields: ['gateway_transaction_id'], name: 'idx_payments_gateway_transaction_id' },
        { fields: ['is_recurring'], name: 'idx_payments_is_recurring' },
        { fields: ['is_partial'], name: 'idx_payments_is_partial' },
        { fields: ['is_prepaid'], name: 'idx_payments_is_prepaid' },
        { fields: ['is_refundable'], name: 'idx_payments_is_refundable' },
        { fields: ['is_processed'], name: 'idx_payments_is_processed' },
        { fields: ['is_settled'], name: 'idx_payments_is_settled' },
        { fields: ['is_archived'], name: 'idx_payments_is_archived' },
        { fields: ['is_auto_renewal'], name: 'idx_payments_is_auto_renewal' },
        { fields: ['is_installment'], name: 'idx_payments_is_installment' },
        { fields: ['created_at'], name: 'idx_payments_created_at' },
        { fields: ['order_id', 'status'], name: 'idx_payments_order_status' },
    ],
})
export class PaymentModel
    extends Model<PaymentModel, IPaymentCreationAttributes>
    implements IPaymentModel
{
    @Column({
        type: DataType.INTEGER,
        primaryKey: true,
        autoIncrement: true,
    })
    declare id: number;

    @ForeignKey(() => OrderModel)
    @Column({
        type: DataType.INTEGER,
        allowNull: false,
        field: 'order_id',
    })
    declare orderId: number;

    @Column({
        type: DataType.DECIMAL(10, 2),
        allowNull: false,
        validate: {
            min: 0
        }
    })
    declare amount: number;

    @Column({
        type: DataType.STRING(3),
        allowNull: false,
        defaultValue: 'RUB',
        validate: {
            isIn: [['RUB', 'USD', 'EUR']]
        }
    })
    declare currency: string;

    @Column({
        type: DataType.ENUM(...Object.values(PaymentStatus)),
        allowNull: false,
        defaultValue: PaymentStatus.PENDING,
    })
    declare status: PaymentStatus;

    @Column({
        type: DataType.ENUM(...Object.values(PaymentMethod)),
        allowNull: false,
        field: 'payment_method',
    })
    declare paymentMethod: PaymentMethod;

    @Column({
        type: DataType.STRING(50),
        allowNull: true,
        field: 'gateway_name',
    })
    declare gatewayName: string;

    @Column({
        type: DataType.STRING(255),
        allowNull: true,
        field: 'gateway_transaction_id',
    })
    declare gatewayTransactionId: string;

    @Column({
        type: DataType.JSONB,
        allowNull: true,
        field: 'gateway_response',
    })
    declare gatewayResponse: any;

    @Column({
        type: DataType.TEXT,
        allowNull: true,
    })
    declare description: string;

    @Column({
        type: DataType.DECIMAL(10, 2),
        allowNull: false,
        defaultValue: 0,
        field: 'refund_amount',
    })
    declare refundAmount: number;

    @Column({
        type: DataType.TEXT,
        allowNull: true,
        field: 'refund_reason',
    })
    declare refundReason: string;

    @Column({
        type: DataType.DATE,
        allowNull: true,
        field: 'processed_at',
    })
    declare processedAt: Date;

    @Column({
        type: DataType.DATE,
        allowNull: true,
        field: 'failed_at',
    })
    declare failedAt: Date;

    @Column({
        type: DataType.DATE,
        allowNull: true,
        field: 'refunded_at',
    })
    declare refundedAt: Date;

    @Column({
        type: DataType.BOOLEAN,
        allowNull: false,
        defaultValue: false,
        field: 'is_recurring',
    })
    declare isRecurring: boolean;

    @Column({
        type: DataType.BOOLEAN,
        allowNull: false,
        defaultValue: false,
        field: 'is_partial',
    })
    declare isPartial: boolean;

    @Column({
        type: DataType.BOOLEAN,
        allowNull: false,
        defaultValue: false,
        field: 'is_prepaid',
    })
    declare isPrepaid: boolean;

    @Column({
        type: DataType.BOOLEAN,
        allowNull: false,
        defaultValue: true,
        field: 'is_refundable',
    })
    declare isRefundable: boolean;

    @Column({
        type: DataType.BOOLEAN,
        allowNull: false,
        defaultValue: false,
        field: 'is_processed',
    })
    declare isProcessed: boolean;

    @Column({
        type: DataType.BOOLEAN,
        allowNull: false,
        defaultValue: false,
        field: 'is_settled',
    })
    declare isSettled: boolean;

    @Column({
        type: DataType.BOOLEAN,
        allowNull: false,
        defaultValue: false,
        field: 'is_archived',
    })
    declare isArchived: boolean;

    @Column({
        type: DataType.BOOLEAN,
        allowNull: false,
        defaultValue: false,
        field: 'is_auto_renewal',
    })
    declare isAutoRenewal: boolean;

    @Column({
        type: DataType.BOOLEAN,
        allowNull: false,
        defaultValue: false,
        field: 'is_installment',
    })
    declare isInstallment: boolean;

    @Column({
        type: DataType.DATE,
        allowNull: false,
        defaultValue: DataType.NOW,
        field: 'created_at',
    })
    declare createdAt: Date;

    @Column({
        type: DataType.DATE,
        allowNull: false,
        defaultValue: DataType.NOW,
        field: 'updated_at',
    })
    declare updatedAt: Date;

    // –°–≤—è–∑–∏
    @BelongsTo(() => OrderModel)
    declare order: OrderModel;

    // –ú–µ—Ç–æ–¥—ã
    get isCompleted(): boolean {
        return this.status === PaymentStatus.COMPLETED;
    }

    get isFailed(): boolean {
        return this.status === PaymentStatus.FAILED;
    }

    get isPending(): boolean {
        return this.status === PaymentStatus.PENDING;
    }

    get isRefunded(): boolean {
        return this.status === PaymentStatus.REFUNDED;
    }

    get canBeRefunded(): boolean {
        return this.isCompleted && this.refundAmount < this.amount;
    }

    get availableRefundAmount(): number {
        return this.amount - this.refundAmount;
    }

    get isRecurringPayment(): boolean {
        return this.isRecurring;
    }

    get isPartialPayment(): boolean {
        return this.isPartial;
    }

    get isPrepaidPayment(): boolean {
        return this.isPrepaid;
    }

    get isRefundablePayment(): boolean {
        return this.isRefundable;
    }

    get isProcessedPayment(): boolean {
        return this.isProcessed;
    }

    get isSettledPayment(): boolean {
        return this.isSettled;
    }

    get isArchivedPayment(): boolean {
        return this.isArchived;
    }

    get isAutoRenewalPayment(): boolean {
        return this.isAutoRenewal;
    }

    get isInstallmentPayment(): boolean {
        return this.isInstallment;
    }

    get paymentType(): string {
        if (this.isRecurring) return 'recurring';
        if (this.isPartial) return 'partial';
        if (this.isPrepaid) return 'prepaid';
        if (this.isInstallment) return 'installment';
        if (this.isArchived) return 'archived';
        return 'regular';
    }

    get paymentStatus(): string {
        if (this.isSettled) return 'settled';
        if (this.isProcessed) return 'processed';
        if (this.isRefunded) return 'refunded';
        if (this.isFailed) return 'failed';
        if (this.isCompleted) return 'completed';
        return 'pending';
    }

    // –ú–µ—Ç–æ–¥ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∞
    async processRefund(amount: number, reason: string): Promise<void> {
        if (!this.canBeRefunded) {
            throw new Error('–ü–ª–∞—Ç–µ–∂ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–æ–∑–≤—Ä–∞—â–µ–Ω');
        }

        if (amount > this.availableRefundAmount) {
            throw new Error('–°—É–º–º–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—É—é —Å—É–º–º—É');
        }

        const newRefundAmount = this.refundAmount + amount;
        const isFullyRefunded = newRefundAmount >= this.amount;

        await this.update({
            refundAmount: newRefundAmount,
            refundReason: reason,
            status: isFullyRefunded ? PaymentStatus.REFUNDED : PaymentStatus.COMPLETED,
            refundedAt: new Date(),
        });
    }

    async markAsRecurring(): Promise<void> {
        await this.update({ isRecurring: true });
    }

    async unmarkAsRecurring(): Promise<void> {
        await this.update({ isRecurring: false });
    }

    async markAsPartial(): Promise<void> {
        await this.update({ isPartial: true });
    }

    async unmarkAsPartial(): Promise<void> {
        await this.update({ isPartial: false });
    }

    async markAsPrepaid(): Promise<void> {
        await this.update({ isPrepaid: true });
    }

    async unmarkAsPrepaid(): Promise<void> {
        await this.update({ isPrepaid: false });
    }

    async markAsRefundable(): Promise<void> {
        await this.update({ isRefundable: true });
    }

    async unmarkAsRefundable(): Promise<void> {
        await this.update({ isRefundable: false });
    }

    async markAsProcessed(): Promise<void> {
        await this.update({ isProcessed: true, processedAt: new Date() });
    }

    async unmarkAsProcessed(): Promise<void> {
        await this.update({ isProcessed: false, processedAt: null });
    }

    async markAsSettled(): Promise<void> {
        await this.update({ isSettled: true });
    }

    async unmarkAsSettled(): Promise<void> {
        await this.update({ isSettled: false });
    }

    async archivePayment(): Promise<void> {
        await this.update({ isArchived: true });
    }

    async unarchivePayment(): Promise<void> {
        await this.update({ isArchived: false });
    }

    async enableAutoRenewal(): Promise<void> {
        await this.update({ isAutoRenewal: true });
    }

    async disableAutoRenewal(): Promise<void> {
        await this.update({ isAutoRenewal: false });
    }

    async enableInstallment(): Promise<void> {
        await this.update({ isInstallment: true });
    }

    async disableInstallment(): Promise<void> {
        await this.update({ isInstallment: false });
    }

    // –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –º–µ—Ç–æ–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–ª–∞–≥–∞–º–∏
    static async getAutoRenewalPayments(): Promise<PaymentModel[]> {
        return this.findAll({
            where: { isAutoRenewal: true },
            order: [['createdAt', 'DESC']],
        });
    }

    static async getNonAutoRenewalPayments(): Promise<PaymentModel[]> {
        return this.findAll({
            where: { isAutoRenewal: false },
            order: [['createdAt', 'DESC']],
        });
    }

    static async getInstallmentPayments(): Promise<PaymentModel[]> {
        return this.findAll({
            where: { isInstallment: true },
            order: [['createdAt', 'DESC']],
        });
    }

    static async getNonInstallmentPayments(): Promise<PaymentModel[]> {
        return this.findAll({
            where: { isInstallment: false },
            order: [['createdAt', 'DESC']],
        });
    }

    static async getArchivedPayments(): Promise<PaymentModel[]> {
        return this.findAll({
            where: { isArchived: true },
            order: [['createdAt', 'DESC']],
        });
    }

    static async getNonArchivedPayments(): Promise<PaymentModel[]> {
        return this.findAll({
            where: { isArchived: false },
            order: [['createdAt', 'DESC']],
        });
    }
}
```

## –°–µ—Ä–≤–∏—Å—ã

### Payment Service
```typescript
// src/infrastructure/services/payment.service.ts
import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import { PaymentModel, PaymentStatus, PaymentMethod } from '@app/domain/models/payment.model';
import { OrderModel } from '@app/domain/models/order.model';

@Injectable()
export class PaymentService {
    private readonly logger = new Logger(PaymentService.name);

    constructor(
        @InjectModel(PaymentModel)
        private paymentModel: typeof PaymentModel,
        @InjectModel(OrderModel)
        private orderModel: typeof OrderModel,
    ) {}

    async createPayment(
        orderId: number,
        paymentData: {
            amount: number;
            currency?: string;
            paymentMethod: PaymentMethod;
            description?: string;
        },
    ): Promise<PaymentModel> {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∑–∞–∫–∞–∑–∞
        const order = await this.orderModel.findByPk(orderId);
        if (!order) {
            throw new NotFoundException('–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω');
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–∫–∞–∑ –Ω–µ –æ–ø–ª–∞—á–µ–Ω
        const existingPayment = await this.paymentModel.findOne({
            where: { 
                orderId,
                status: PaymentStatus.COMPLETED,
            },
        });

        if (existingPayment) {
            throw new BadRequestException('–ó–∞–∫–∞–∑ —É–∂–µ –æ–ø–ª–∞—á–µ–Ω');
        }

        const payment = await this.paymentModel.create({
            orderId,
            amount: paymentData.amount,
            currency: paymentData.currency || 'RUB',
            paymentMethod: paymentData.paymentMethod,
            description: paymentData.description,
            status: PaymentStatus.PENDING,
        });

        this.logger.log(`–°–æ–∑–¥–∞–Ω –ø–ª–∞—Ç–µ–∂ ${payment.id} –¥–ª—è –∑–∞–∫–∞–∑–∞ ${orderId}`);
        return payment;
    }

    async processPayment(
        paymentId: number,
        gatewayData: {
            gatewayName: string;
            gatewayTransactionId: string;
            gatewayResponse: any;
        },
    ): Promise<PaymentModel> {
        const payment = await this.getPaymentById(paymentId);

        if (payment.status !== PaymentStatus.PENDING) {
            throw new BadRequestException('–ü–ª–∞—Ç–µ–∂ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω');
        }

        // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –ø–ª–∞—Ç–µ–∂–Ω—ã–º —à–ª—é–∑–æ–º
        // –î–ª—è –ø—Ä–∏–º–µ—Ä–∞ –ø—Ä–æ—Å—Ç–æ –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π
        await payment.update({
            status: PaymentStatus.COMPLETED,
            gatewayName: gatewayData.gatewayName,
            gatewayTransactionId: gatewayData.gatewayTransactionId,
            gatewayResponse: gatewayData.gatewayResponse,
            processedAt: new Date(),
        });

        this.logger.log(`–ü–ª–∞—Ç–µ–∂ ${paymentId} –æ–±—Ä–∞–±–æ—Ç–∞–Ω —á–µ—Ä–µ–∑ ${gatewayData.gatewayName}`);
        return payment;
    }

    async failPayment(
        paymentId: number,
        reason?: string,
    ): Promise<PaymentModel> {
        const payment = await this.getPaymentById(paymentId);

        if (payment.status !== PaymentStatus.PENDING) {
            throw new BadRequestException('–ü–ª–∞—Ç–µ–∂ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω');
        }

        await payment.update({
            status: PaymentStatus.FAILED,
            description: reason,
            failedAt: new Date(),
        });

        this.logger.log(`–ü–ª–∞—Ç–µ–∂ ${paymentId} –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π: ${reason}`);
        return payment;
    }

    async refundPayment(
        paymentId: number,
        amount: number,
        reason: string,
    ): Promise<PaymentModel> {
        const payment = await this.getPaymentById(paymentId);

        await payment.processRefund(amount, reason);

        this.logger.log(`–í–æ–∑–≤—Ä–∞—Ç ${amount} —Ä—É–±. –¥–ª—è –ø–ª–∞—Ç–µ–∂–∞ ${paymentId}: ${reason}`);
        return payment;
    }

    async getPaymentById(paymentId: number): Promise<PaymentModel> {
        const payment = await this.paymentModel.findByPk(paymentId, {
            include: [{ association: 'order' }],
        });

        if (!payment) {
            throw new NotFoundException('–ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω');
        }

        return payment;
    }

    async getOrderPayments(orderId: number): Promise<PaymentModel[]> {
        return this.paymentModel.findAll({
            where: { orderId },
            order: [['created_at', 'DESC']],
        });
    }

    async getPaymentStatistics(): Promise<{
        totalPayments: number;
        completedPayments: number;
        failedPayments: number;
        refundedPayments: number;
        totalAmount: number;
        totalRefunded: number;
        installmentPayments: number;
        autoRenewalPayments: number;
    }> {
        const [
            totalPayments,
            completedPayments,
            failedPayments,
            refundedPayments,
            totalAmountResult,
            totalRefundedResult,
            installmentPayments,
            autoRenewalPayments,
        ] = await Promise.all([
            this.paymentModel.count(),
            this.paymentModel.count({ where: { status: PaymentStatus.COMPLETED } }),
            this.paymentModel.count({ where: { status: PaymentStatus.FAILED } }),
            this.paymentModel.count({ where: { status: PaymentStatus.REFUNDED } }),
            this.paymentModel.sum('amount'),
            this.paymentModel.sum('refund_amount'),
            this.paymentModel.count({ where: { isInstallment: true } }),
            this.paymentModel.count({ where: { isAutoRenewal: true } }),
        ]);

        return {
            totalPayments,
            completedPayments,
            failedPayments,
            refundedPayments,
            totalAmount: totalAmountResult || 0,
            totalRefunded: totalRefundedResult || 0,
            installmentPayments,
            autoRenewalPayments,
        };
    }

    async getPaymentsByMethod(paymentMethod: PaymentMethod): Promise<PaymentModel[]> {
        return this.paymentModel.findAll({
            where: { paymentMethod },
            order: [['created_at', 'DESC']],
            limit: 100,
        });
    }

    async getPaymentsByStatus(status: PaymentStatus): Promise<PaymentModel[]> {
        return this.paymentModel.findAll({
            where: { status },
            order: [['created_at', 'DESC']],
            limit: 100,
        });
    }

    async getInstallmentPayments(): Promise<PaymentModel[]> {
        return this.paymentModel.findAll({
            where: { isInstallment: true },
            order: [['created_at', 'DESC']],
        });
    }

    async getAutoRenewalPayments(): Promise<PaymentModel[]> {
        return this.paymentModel.findAll({
            where: { isAutoRenewal: true },
            order: [['created_at', 'DESC']],
        });
    }
}
```

## –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã

### Payment Controller
```typescript
// src/infrastructure/controllers/payment.controller.ts
import { Controller, Get, Post, Put, Param, Body, Query, HttpCode, HttpStatus, UseGuards } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiQuery, ApiBearerAuth } from '@nestjs/swagger';
import { AuthGuard } from '@app/infrastructure/common/guards/auth.guard';
import { CurrentUser } from '@app/infrastructure/common/decorators/current-user.decorator';
import { PaymentService } from '@app/infrastructure/services/payment.service';
import { CreatePaymentDto } from '@app/infrastructure/dto/payment/create-payment.dto';
import { ProcessPaymentDto } from '@app/infrastructure/dto/payment/process-payment.dto';
import { RefundPaymentDto } from '@app/infrastructure/dto/payment/refund-payment.dto';
import { PaymentResponse, PaymentStatisticsResponse } from '@app/infrastructure/responses/payment/payment.response';

@ApiTags('–ü–ª–∞—Ç–µ–∂–∏')
@Controller('payments')
export class PaymentController {
    constructor(private readonly paymentService: PaymentService) {}

    @Post()
    @HttpCode(HttpStatus.CREATED)
    @UseGuards(AuthGuard)
    @ApiBearerAuth('JWT-auth')
    @ApiOperation({ summary: '–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø–ª–∞—Ç–µ–∂' })
    @ApiResponse({ status: 201, description: '–ü–ª–∞—Ç–µ–∂ —Å–æ–∑–¥–∞–Ω', type: PaymentResponse })
    async createPayment(
        @Body() createPaymentDto: CreatePaymentDto,
    ): Promise<PaymentResponse> {
        const payment = await this.paymentService.createPayment(
            createPaymentDto.orderId,
            {
                amount: createPaymentDto.amount,
                currency: createPaymentDto.currency,
                paymentMethod: createPaymentDto.paymentMethod,
                description: createPaymentDto.description,
            },
        );
        
        return {
            id: payment.id,
            orderId: payment.orderId,
            amount: payment.amount,
            currency: payment.currency,
            status: payment.status,
            paymentMethod: payment.paymentMethod,
            gatewayName: payment.gatewayName,
            gatewayTransactionId: payment.gatewayTransactionId,
            gatewayResponse: payment.gatewayResponse,
            description: payment.description,
            refundAmount: payment.refundAmount,
            refundReason: payment.refundReason,
            processedAt: payment.processedAt,
            failedAt: payment.failedAt,
            refundedAt: payment.refundedAt,
            createdAt: payment.createdAt,
            updatedAt: payment.updatedAt,
        };
    }

    @Put(':id/process')
    @HttpCode(HttpStatus.OK)
    @UseGuards(AuthGuard)
    @ApiBearerAuth('JWT-auth')
    @ApiOperation({ summary: '–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø–ª–∞—Ç–µ–∂' })
    @ApiResponse({ status: 200, description: '–ü–ª–∞—Ç–µ–∂ –æ–±—Ä–∞–±–æ—Ç–∞–Ω', type: PaymentResponse })
    @ApiResponse({ status: 400, description: '–ü–ª–∞—Ç–µ–∂ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω' })
    @ApiResponse({ status: 404, description: '–ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω' })
    async processPayment(
        @Param('id') paymentId: number,
        @Body() processPaymentDto: ProcessPaymentDto,
    ): Promise<PaymentResponse> {
        const payment = await this.paymentService.processPayment(paymentId, {
            gatewayName: processPaymentDto.gatewayName,
            gatewayTransactionId: processPaymentDto.gatewayTransactionId,
            gatewayResponse: processPaymentDto.gatewayResponse,
        });
        
        return {
            id: payment.id,
            orderId: payment.orderId,
            amount: payment.amount,
            currency: payment.currency,
            status: payment.status,
            paymentMethod: payment.paymentMethod,
            gatewayName: payment.gatewayName,
            gatewayTransactionId: payment.gatewayTransactionId,
            gatewayResponse: payment.gatewayResponse,
            description: payment.description,
            refundAmount: payment.refundAmount,
            refundReason: payment.refundReason,
            processedAt: payment.processedAt,
            failedAt: payment.failedAt,
            refundedAt: payment.refundedAt,
            createdAt: payment.createdAt,
            updatedAt: payment.updatedAt,
        };
    }

    @Put(':id/fail')
    @HttpCode(HttpStatus.OK)
    @UseGuards(AuthGuard)
    @ApiBearerAuth('JWT-auth')
    @ApiOperation({ summary: '–û—Ç–º–µ—Ç–∏—Ç—å –ø–ª–∞—Ç–µ–∂ –∫–∞–∫ –Ω–µ—É–¥–∞—á–Ω—ã–π' })
    @ApiResponse({ status: 200, description: '–ü–ª–∞—Ç–µ–∂ –æ—Ç–º–µ—á–µ–Ω –∫–∞–∫ –Ω–µ—É–¥–∞—á–Ω—ã–π', type: PaymentResponse })
    @ApiResponse({ status: 400, description: '–ü–ª–∞—Ç–µ–∂ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω' })
    @ApiResponse({ status: 404, description: '–ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω' })
    async failPayment(
        @Param('id') paymentId: number,
        @Body('reason') reason?: string,
    ): Promise<PaymentResponse> {
        const payment = await this.paymentService.failPayment(paymentId, reason);
        
        return {
            id: payment.id,
            orderId: payment.orderId,
            amount: payment.amount,
            currency: payment.currency,
            status: payment.status,
            paymentMethod: payment.paymentMethod,
            gatewayName: payment.gatewayName,
            gatewayTransactionId: payment.gatewayTransactionId,
            gatewayResponse: payment.gatewayResponse,
            description: payment.description,
            refundAmount: payment.refundAmount,
            refundReason: payment.refundReason,
            processedAt: payment.processedAt,
            failedAt: payment.failedAt,
            refundedAt: payment.refundedAt,
            createdAt: payment.createdAt,
            updatedAt: payment.updatedAt,
        };
    }

    @Put(':id/refund')
    @HttpCode(HttpStatus.OK)
    @UseGuards(AuthGuard)
    @ApiBearerAuth('JWT-auth')
    @ApiOperation({ summary: '–í–æ–∑–≤—Ä–∞—Ç –ø–ª–∞—Ç–µ–∂–∞' })
    @ApiResponse({ status: 200, description: '–í–æ–∑–≤—Ä–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω', type: PaymentResponse })
    @ApiResponse({ status: 400, description: '–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å –ø–ª–∞—Ç–µ–∂' })
    @ApiResponse({ status: 404, description: '–ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω' })
    async refundPayment(
        @Param('id') paymentId: number,
        @Body() refundPaymentDto: RefundPaymentDto,
    ): Promise<PaymentResponse> {
        const payment = await this.paymentService.refundPayment(
            paymentId,
            refundPaymentDto.amount,
            refundPaymentDto.reason,
        );
        
        return {
            id: payment.id,
            orderId: payment.orderId,
            amount: payment.amount,
            currency: payment.currency,
            status: payment.status,
            paymentMethod: payment.paymentMethod,
            gatewayName: payment.gatewayName,
            gatewayTransactionId: payment.gatewayTransactionId,
            gatewayResponse: payment.gatewayResponse,
            description: payment.description,
            refundAmount: payment.refundAmount,
            refundReason: payment.refundReason,
            processedAt: payment.processedAt,
            failedAt: payment.failedAt,
            refundedAt: payment.refundedAt,
            createdAt: payment.createdAt,
            updatedAt: payment.updatedAt,
        };
    }

    @Get(':id')
    @HttpCode(HttpStatus.OK)
    @UseGuards(AuthGuard)
    @ApiBearerAuth('JWT-auth')
    @ApiOperation({ summary: '–ü–æ–ª—É—á–∏—Ç—å –ø–ª–∞—Ç–µ–∂ –ø–æ ID' })
    @ApiResponse({ status: 200, description: '–ü–ª–∞—Ç–µ–∂ –ø–æ–ª—É—á–µ–Ω', type: PaymentResponse })
    @ApiResponse({ status: 404, description: '–ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω' })
    async getPaymentById(@Param('id') paymentId: number): Promise<PaymentResponse> {
        const payment = await this.paymentService.getPaymentById(paymentId);
        
        return {
            id: payment.id,
            orderId: payment.orderId,
            amount: payment.amount,
            currency: payment.currency,
            status: payment.status,
            paymentMethod: payment.paymentMethod,
            gatewayName: payment.gatewayName,
            gatewayTransactionId: payment.gatewayTransactionId,
            gatewayResponse: payment.gatewayResponse,
            description: payment.description,
            refundAmount: payment.refundAmount,
            refundReason: payment.refundReason,
            processedAt: payment.processedAt,
            failedAt: payment.failedAt,
            refundedAt: payment.refundedAt,
            createdAt: payment.createdAt,
            updatedAt: payment.updatedAt,
        };
    }

    @Get('order/:orderId')
    @HttpCode(HttpStatus.OK)
    @UseGuards(AuthGuard)
    @ApiBearerAuth('JWT-auth')
    @ApiOperation({ summary: '–ü–æ–ª—É—á–∏—Ç—å –ø–ª–∞—Ç–µ–∂–∏ –∑–∞–∫–∞–∑–∞' })
    @ApiResponse({ status: 200, description: '–ü–ª–∞—Ç–µ–∂–∏ –ø–æ–ª—É—á–µ–Ω—ã', type: [PaymentResponse] })
    async getOrderPayments(@Param('orderId') orderId: number): Promise<PaymentResponse[]> {
        const payments = await this.paymentService.getOrderPayments(orderId);
        
        return payments.map(payment => ({
            id: payment.id,
            orderId: payment.orderId,
            amount: payment.amount,
            currency: payment.currency,
            status: payment.status,
            paymentMethod: payment.paymentMethod,
            gatewayName: payment.gatewayName,
            gatewayTransactionId: payment.gatewayTransactionId,
            gatewayResponse: payment.gatewayResponse,
            description: payment.description,
            refundAmount: payment.refundAmount,
            refundReason: payment.refundReason,
            processedAt: payment.processedAt,
            failedAt: payment.failedAt,
            refundedAt: payment.refundedAt,
            createdAt: payment.createdAt,
            updatedAt: payment.updatedAt,
        }));
    }

    @Get('admin/statistics')
    @HttpCode(HttpStatus.OK)
    @UseGuards(AuthGuard)
    @ApiBearerAuth('JWT-auth')
    @ApiOperation({ summary: '–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–ª–∞—Ç–µ–∂–µ–π (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤)' })
    @ApiResponse({ status: 200, description: '–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—É—á–µ–Ω–∞', type: PaymentStatisticsResponse })
    async getPaymentStatistics(): Promise<PaymentStatisticsResponse> {
        const statistics = await this.paymentService.getPaymentStatistics();
        
        return {
            totalPayments: statistics.totalPayments,
            completedPayments: statistics.completedPayments,
            failedPayments: statistics.failedPayments,
            refundedPayments: statistics.refundedPayments,
            totalAmount: statistics.totalAmount,
            totalRefunded: statistics.totalRefunded,
        };
    }

    @Get('method/:method')
    @HttpCode(HttpStatus.OK)
    @UseGuards(AuthGuard)
    @ApiBearerAuth('JWT-auth')
    @ApiOperation({ summary: '–ü–æ–ª—É—á–∏—Ç—å –ø–ª–∞—Ç–µ–∂–∏ –ø–æ –º–µ—Ç–æ–¥—É –æ–ø–ª–∞—Ç—ã' })
    @ApiResponse({ status: 200, description: '–ü–ª–∞—Ç–µ–∂–∏ –ø–æ–ª—É—á–µ–Ω—ã', type: [PaymentResponse] })
    async getPaymentsByMethod(
        @Param('method') method: string,
    ): Promise<PaymentResponse[]> {
        const payments = await this.paymentService.getPaymentsByMethod(method as any);
        
        return payments.map(payment => ({
            id: payment.id,
            orderId: payment.orderId,
            amount: payment.amount,
            currency: payment.currency,
            status: payment.status,
            paymentMethod: payment.paymentMethod,
            gatewayName: payment.gatewayName,
            gatewayTransactionId: payment.gatewayTransactionId,
            gatewayResponse: payment.gatewayResponse,
            description: payment.description,
            refundAmount: payment.refundAmount,
            refundReason: payment.refundReason,
            processedAt: payment.processedAt,
            failedAt: payment.failedAt,
            refundedAt: payment.refundedAt,
            createdAt: payment.createdAt,
            updatedAt: payment.updatedAt,
        }));
    }
}
```

## –ú–∏–≥—Ä–∞—Ü–∏–∏

### –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã payments
```typescript
// db/migrations/YYYYMMDDHHMMSS-create-payments-table.ts
import { QueryInterface, DataTypes } from 'sequelize';

export async function up(queryInterface: QueryInterface): Promise<void> {
    await queryInterface.createTable('payments', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true,
        },
        order_id: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: { model: 'orders', key: 'id' },
            onDelete: 'CASCADE',
        },
        amount: {
            type: DataTypes.DECIMAL(10, 2),
            allowNull: false,
        },
        currency: {
            type: DataTypes.STRING(3),
            allowNull: false,
            defaultValue: 'RUB',
        },
        status: {
            type: DataTypes.ENUM('pending', 'completed', 'failed', 'refunded'),
            allowNull: false,
            defaultValue: 'pending',
        },
        payment_method: {
            type: DataTypes.ENUM('card', 'cash', 'bank_transfer'),
            allowNull: false,
        },
        gateway_name: {
            type: DataTypes.STRING(50),
            allowNull: true,
        },
        gateway_transaction_id: {
            type: DataTypes.STRING(255),
            allowNull: true,
        },
        gateway_response: {
            type: DataTypes.JSONB,
            allowNull: true,
        },
        description: {
            type: DataTypes.TEXT,
            allowNull: true,
        },
        refund_amount: {
            type: DataTypes.DECIMAL(10, 2),
            allowNull: false,
            defaultValue: 0,
        },
        refund_reason: {
            type: DataTypes.TEXT,
            allowNull: true,
        },
        processed_at: {
            type: DataTypes.DATE,
            allowNull: true,
        },
        failed_at: {
            type: DataTypes.DATE,
            allowNull: true,
        },
        refunded_at: {
            type: DataTypes.DATE,
            allowNull: true,
        },
        created_at: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW,
        },
        updated_at: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW,
        },
    });

    // –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã
    await Promise.all([
        queryInterface.addIndex('payments', ['order_id']),
        queryInterface.addIndex('payments', ['status']),
        queryInterface.addIndex('payments', ['payment_method']),
        queryInterface.addIndex('payments', ['gateway_name']),
        queryInterface.addIndex('payments', ['gateway_transaction_id']),
        queryInterface.addIndex('payments', ['created_at']),
        queryInterface.addIndex('payments', ['order_id', 'status']),
    ]);
}

export async function down(queryInterface: QueryInterface): Promise<void> {
    await queryInterface.dropTable('payments');
}
```

## DTO –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è

### CreatePaymentDto
```typescript
// src/infrastructure/dto/payment/create-payment.dto.ts
import { IsNumber, IsOptional, IsString, Min, IsEnum, IsIn } from 'class-validator';
import { PaymentMethod } from '@app/domain/models/payment.model';

export class CreatePaymentDto {
    @IsNumber({}, { message: 'ID –∑–∞–∫–∞–∑–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º' })
    @Min(1, { message: 'ID –∑–∞–∫–∞–∑–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±–æ–ª—å—à–µ 0' })
    declare readonly orderId: number;

    @IsNumber({}, { message: '–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á–∏—Å–ª–æ–º' })
    @Min(0.01, { message: '–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0' })
    declare readonly amount: number;

    @IsOptional()
    @IsString({ message: '–í–∞–ª—é—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π' })
    @IsIn(['RUB', 'USD', 'EUR'], { message: '–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è –≤–∞–ª—é—Ç–∞' })
    declare readonly currency?: string;

    @IsEnum(PaymentMethod, { message: '–ù–µ–≤–µ—Ä–Ω—ã–π –º–µ—Ç–æ–¥ –æ–ø–ª–∞—Ç—ã' })
    declare readonly paymentMethod: PaymentMethod;

    @IsOptional()
    @IsString({ message: '–û–ø–∏—Å–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π' })
    declare readonly description?: string;

    @IsOptional()
    @IsBoolean({ message: '–§–ª–∞–≥ —Ä–∞—Å—Å—Ä–æ—á–∫–∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±—É–ª–µ–≤—ã–º' })
    declare readonly isInstallment?: boolean;
}
```

### ProcessPaymentDto
```typescript
// src/infrastructure/dto/payment/process-payment.dto.ts
import { IsString, IsNotEmpty, IsObject, IsOptional } from 'class-validator';

export class ProcessPaymentDto {
    @IsString({ message: '–ù–∞–∑–≤–∞–Ω–∏–µ —à–ª—é–∑–∞ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π' })
    @IsNotEmpty({ message: '–ù–∞–∑–≤–∞–Ω–∏–µ —à–ª—é–∑–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º' })
    declare readonly gatewayName: string;

    @IsString({ message: 'ID —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π' })
    @IsNotEmpty({ message: 'ID —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º' })
    declare readonly gatewayTransactionId: string;

    @IsOptional()
    @IsObject({ message: '–û—Ç–≤–µ—Ç —à–ª—é–∑–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–±—ä–µ–∫—Ç–æ–º' })
    declare readonly gatewayResponse?: any;
}
```

### RefundPaymentDto
```typescript
// src/infrastructure/dto/payment/refund-payment.dto.ts
import { IsNumber, IsString, IsNotEmpty, Min } from 'class-validator';

export class RefundPaymentDto {
    @IsNumber({}, { message: '–°—É–º–º–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á–∏—Å–ª–æ–º' })
    @Min(0.01, { message: '–°—É–º–º–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0' })
    declare readonly amount: number;

    @IsString({ message: '–ü—Ä–∏—á–∏–Ω–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π' })
    @IsNotEmpty({ message: '–ü—Ä–∏—á–∏–Ω–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç–æ–π' })
    declare readonly reason: string;
}
```

## Response –∫–ª–∞—Å—Å—ã

### PaymentResponse
```typescript
// src/infrastructure/responses/payment/payment.response.ts
import { ApiProperty } from '@nestjs/swagger';

export class PaymentResponse {
    @ApiProperty({ description: 'ID –ø–ª–∞—Ç–µ–∂–∞' })
    declare readonly id: number;

    @ApiProperty({ description: 'ID –∑–∞–∫–∞–∑–∞' })
    declare readonly orderId: number;

    @ApiProperty({ description: '–°—É–º–º–∞ –ø–ª–∞—Ç–µ–∂–∞' })
    declare readonly amount: number;

    @ApiProperty({ description: '–í–∞–ª—é—Ç–∞' })
    declare readonly currency: string;

    @ApiProperty({ description: '–°—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞' })
    declare readonly status: string;

    @ApiProperty({ description: '–ú–µ—Ç–æ–¥ –æ–ø–ª–∞—Ç—ã' })
    declare readonly paymentMethod: string;

    @ApiProperty({ description: '–ù–∞–∑–≤–∞–Ω–∏–µ —à–ª—é–∑–∞', required: false })
    declare readonly gatewayName?: string;

    @ApiProperty({ description: 'ID —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –≤ —à–ª—é–∑–µ', required: false })
    declare readonly gatewayTransactionId?: string;

    @ApiProperty({ description: '–û—Ç–≤–µ—Ç –æ—Ç —à–ª—é–∑–∞', required: false })
    declare readonly gatewayResponse?: any;

    @ApiProperty({ description: '–û–ø–∏—Å–∞–Ω–∏–µ', required: false })
    declare readonly description?: string;

    @ApiProperty({ description: '–°—É–º–º–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞' })
    declare readonly refundAmount: number;

    @ApiProperty({ description: '–ü—Ä–∏—á–∏–Ω–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞', required: false })
    declare readonly refundReason?: string;

    @ApiProperty({ description: '–î–∞—Ç–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏', required: false })
    declare readonly processedAt?: Date;

    @ApiProperty({ description: '–î–∞—Ç–∞ –æ—à–∏–±–∫–∏', required: false })
    declare readonly failedAt?: Date;

    @ApiProperty({ description: '–î–∞—Ç–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞', required: false })
    declare readonly refundedAt?: Date;

    @ApiProperty({ description: '–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è' })
    declare readonly createdAt: Date;

    @ApiProperty({ description: '–î–∞—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è' })
    declare readonly updatedAt: Date;

    @ApiProperty({ description: '–†–∞—Å—Å—Ä–æ—á–∫–∞ –ø–ª–∞—Ç–µ–∂–∞' })
    declare readonly isInstallment: boolean;
}
```

### PaymentStatisticsResponse
```typescript
// src/infrastructure/responses/payment/payment.response.ts
import { ApiProperty } from '@nestjs/swagger';

export class PaymentStatisticsResponse {
    @ApiProperty({ description: '–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–ª–∞—Ç–µ–∂–µ–π' })
    declare readonly totalPayments: number;

    @ApiProperty({ description: '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π' })
    declare readonly completedPayments: number;

    @ApiProperty({ description: '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π' })
    declare readonly failedPayments: number;

    @ApiProperty({ description: '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π' })
    declare readonly refundedPayments: number;

    @ApiProperty({ description: '–û–±—â–∞—è —Å—É–º–º–∞ –ø–ª–∞—Ç–µ–∂–µ–π' })
    declare readonly totalAmount: number;

    @ApiProperty({ description: '–û–±—â–∞—è —Å—É–º–º–∞ –≤–æ–∑–≤—Ä–∞—Ç–æ–≤' })
    declare readonly totalRefunded: number;

    @ApiProperty({ description: '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–ª–∞—Ç–µ–∂–µ–π –≤ —Ä–∞—Å—Å—Ä–æ—á–∫—É' })
    declare readonly installmentPayments: number;

    @ApiProperty({ description: '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–ª–∞—Ç–µ–∂–µ–π —Å –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ–º' })
    declare readonly autoRenewalPayments: number;
}
```

## –ö—Ä–∏—Ç–µ—Ä–∏–∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏

### ‚úÖ –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è:
- [ ] –°–æ–∑–¥–∞–Ω–∞ –º–∏–≥—Ä–∞—Ü–∏—è –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã payments
- [ ] –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ –º–æ–¥–µ–ª—å Sequelize PaymentModel
- [ ] –°–æ–∑–¥–∞–Ω PaymentService —Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –ø–ª–∞—Ç–µ–∂–∞–º–∏
- [ ] –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —Å API endpoints
- [ ] –î–æ–±–∞–≤–ª–µ–Ω—ã DTO –∫–ª–∞—Å—Å—ã —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π
- [ ] –°–æ–∑–¥–∞–Ω—ã Response –∫–ª–∞—Å—Å—ã —Å Swagger
- [ ] –î–æ–±–∞–≤–ª–µ–Ω—ã –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
- [ ] –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–µ–π
- [ ] –î–æ–±–∞–≤–ª–µ–Ω—ã unit —Ç–µ—Å—Ç—ã –¥–ª—è —Å–µ—Ä–≤–∏—Å–æ–≤
- [ ] –î–æ–±–∞–≤–ª–µ–Ω—ã integration —Ç–µ—Å—Ç—ã –¥–ª—è API
- [ ] –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–∏–º–∏ –ø–ª–∞—Ç–µ–∂–Ω—ã–º–∏ —à–ª—é–∑–∞–º–∏

### üéØ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:
- [ ] –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–≤ –ø–ª–∞—Ç–µ–∂–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- [ ] –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö —à–ª—é–∑–æ–≤
- [ ] –ß–∞—Å—Ç–∏—á–Ω—ã–µ –≤–æ–∑–≤—Ä–∞—Ç—ã –ø–ª–∞—Ç–µ–∂–µ–π
- [ ] –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–æ–≤ —á–µ—Ä–µ–∑ webhook
- [ ] –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π –ø–æ –º–µ—Ç–æ–¥–∞–º

## –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏

### –§–∞–∑–∞ 1: –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è (1 –Ω–µ–¥–µ–ª—è)
1. **–°–æ–∑–¥–∞—Ç—å –º–∏–≥—Ä–∞—Ü–∏—é** –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã payments
2. **–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –º–æ–¥–µ–ª—å** Sequelize
3. **–°–æ–∑–¥–∞—Ç—å DTO –∫–ª–∞—Å—Å—ã** —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π
4. **–°–æ–∑–¥–∞—Ç—å Response –∫–ª–∞—Å—Å—ã** —Å Swagger
5. **–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–µ—Ä–≤–∏—Å** —Å –æ—Å–Ω–æ–≤–Ω–æ–π –ª–æ–≥–∏–∫–æ–π

### –§–∞–∑–∞ 2: API –∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ (3-4 –¥–Ω—è)
6. **–°–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä** —Å API endpoints
7. **–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é** —Å –ø–ª–∞—Ç–µ–∂–Ω—ã–º–∏ —à–ª—é–∑–∞–º–∏
8. **–î–æ–±–∞–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏—é** –ø–ª–∞—Ç–µ–∂–µ–π –∏ –≤–æ–∑–≤—Ä–∞—Ç–æ–≤
9. **–°–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç—ã** –¥–ª—è API

### –§–∞–∑–∞ 3: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –∫–∞—á–µ—Å—Ç–≤–æ (2-3 –¥–Ω—è)
10. **–ù–∞–ø–∏—Å–∞—Ç—å unit —Ç–µ—Å—Ç—ã** –¥–ª—è —Å–µ—Ä–≤–∏—Å–æ–≤
11. **–ù–∞–ø–∏—Å–∞—Ç—å integration —Ç–µ—Å—Ç—ã** –¥–ª—è API
12. **–î–æ–±–∞–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫** –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—é
13. **–ü—Ä–æ–≤–µ—Å—Ç–∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥** –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é

## –†–∏—Å–∫–∏ –∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã

### ‚ö†Ô∏è –†–∏—Å–∫–∏:
- **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å**: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- **–ö–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å**: –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π
- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–ª–∞—Ç–µ–∂–µ–π

### üîÑ –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã:
- **–í–Ω–µ—à–Ω–∏–µ —Å–µ—Ä–≤–∏—Å—ã**: Stripe, PayPal –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–µ–π
- **–û—á–µ—Ä–µ–¥—å —Å–æ–æ–±—â–µ–Ω–∏–π**: Redis/RabbitMQ –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
- **–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ**: Redis –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–æ–≤ –ø–ª–∞—Ç–µ–∂–µ–π

## –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –¥—Ä—É–≥–∏–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏

### üîó –°–≤—è–∑–∞–Ω–Ω—ã–µ —Å–∏—Å—Ç–µ–º—ã:
- **OrderService** - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞–º–∏
- **NotificationService** - —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å—Ç–∞—Ç—É—Å–µ –ø–ª–∞—Ç–µ–∂–∞
- **UserService** - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
- **ExternalGatewayService** - –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –ø–ª–∞—Ç–µ–∂–Ω—ã–º–∏ —à–ª—é–∑–∞–º–∏

### üìä –ê–Ω–∞–ª–∏—Ç–∏–∫–∞:
- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π –ø–æ –º–µ—Ç–æ–¥–∞–º
- –ü—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—à–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π
- –°—Ä–µ–¥–Ω—è—è —Å—É–º–º–∞ –ø–ª–∞—Ç–µ–∂–∞
- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞—Å—Å—Ä–æ—á–∫–∏ –∏ –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏—è

## TL;DR

–£–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–ª–∞—Ç–µ–∂–µ–π –≤–∫–ª—é—á–∞–µ—Ç:
- **1 —Ç–∞–±–ª–∏—Ü–∞**: payments
- **1 –º–æ–¥–µ–ª—å**: PaymentModel
- **1 —Å–µ—Ä–≤–∏—Å**: PaymentService
- **1 –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä**: PaymentController
- **–§—É–Ω–∫—Ü–∏–∏**: –±–∞–∑–æ–≤—ã–µ —Å—Ç–∞—Ç—É—Å—ã, –ø—Ä–æ—Å—Ç—ã–µ –º–µ—Ç–æ–¥—ã, –≤–æ–∑–≤—Ä–∞—Ç—ã, —Ä–∞—Å—Å—Ä–æ—á–∫–∞
- **–í–∞–ª–∏–¥–∞—Ü–∏—è**: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π –∏ –≤–æ–∑–≤—Ä–∞—Ç–æ–≤
- **–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è**: –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–∏–º–∏ —à–ª—é–∑–∞–º–∏
- **–ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å**: –∫ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—é –∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º —Ñ—É–Ω–∫—Ü–∏—è–º

### üè∑Ô∏è **Boolean —Ñ–ª–∞–≥–∏:**
- **isRecurring** - –†–µ–≥—É–ª—è—Ä–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏ (–ø–æ–¥–ø–∏—Å–∫–∏)
- **isPartial** - –ß–∞—Å—Ç–∏—á–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏
- **isPrepaid** - –ü—Ä–µ–¥–æ–ø–ª–∞—á–µ–Ω–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏
- **isRefundable** - –í–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ –ø–ª–∞—Ç–µ–∂–∏
- **isProcessed** - –û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏
- **isSettled** - –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏
- **isArchived** - –ê—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏
- **isAutoRenewal** - –ê–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–µ–π
- **isInstallment** - –†–∞—Å—Å—Ä–æ—á–∫–∞ –ø–ª–∞—Ç–µ–∂–∞ (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö —Å–∏—Å—Ç–µ–º)
```